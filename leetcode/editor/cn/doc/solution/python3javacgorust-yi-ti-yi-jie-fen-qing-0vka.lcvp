**æ–¹æ³•ä¸€ï¼šåˆ†æƒ…å†µè®¨è®º**

æˆ‘ä»¬ç”¨ä¸€ä¸ªå˜é‡ $blockComment$ æ¥è¡¨ç¤ºå½“å‰æ˜¯å¦å¤„äºŽå—æ³¨é‡Šä¸­ï¼Œåˆå§‹æ—¶ $blockComment$ ä¸º `false`ï¼›ç”¨ä¸€ä¸ªå˜é‡ $t$ æ¥å­˜å‚¨å½“å‰è¡Œçš„æœ‰æ•ˆå­—ç¬¦ã€‚

æŽ¥ä¸‹æ¥ï¼ŒéåŽ†æ¯ä¸€è¡Œï¼Œåˆ†æƒ…å†µè®¨è®ºï¼š

å¦‚æžœå½“å‰å¤„äºŽå—æ³¨é‡Šä¸­ï¼Œé‚£ä¹ˆå¦‚æžœå½“å‰å­—ç¬¦å’Œä¸‹ä¸€ä¸ªå­—ç¬¦æ˜¯ `'*/'`ï¼Œè¯´æ˜Žå—æ³¨é‡Šç»“æŸï¼Œæˆ‘ä»¬å°† $blockComment$ ç½®ä¸º `false`ï¼Œå¹¶ä¸”è·³è¿‡è¿™ä¸¤ä¸ªå­—ç¬¦ï¼›å¦åˆ™ï¼Œæˆ‘ä»¬ç»§ç»­ä¿æŒå—æ³¨é‡ŠçŠ¶æ€ï¼Œä¸åšä»»ä½•æ“ä½œï¼›

å¦‚æžœå½“å‰ä¸å¤„äºŽå—æ³¨é‡Šä¸­ï¼Œé‚£ä¹ˆå¦‚æžœå½“å‰å­—ç¬¦å’Œä¸‹ä¸€ä¸ªå­—ç¬¦æ˜¯ `'/*'`ï¼Œè¯´æ˜Žå—æ³¨é‡Šå¼€å§‹ï¼Œæˆ‘ä»¬å°† $blockComment$ ç½®ä¸º `true`ï¼Œå¹¶ä¸”è·³è¿‡è¿™ä¸¤ä¸ªå­—ç¬¦ï¼›å¦‚æžœå½“å‰å­—ç¬¦å’Œä¸‹ä¸€ä¸ªå­—ç¬¦æ˜¯ `'//'`ï¼Œé‚£ä¹ˆè¯´æ˜Žè¡Œæ³¨é‡Šå¼€å§‹ï¼Œæˆ‘ä»¬ç›´æŽ¥é€€å‡ºå½“å‰è¡Œçš„éåŽ†ï¼›å¦åˆ™ï¼Œè¯´æ˜Žå½“å‰å­—ç¬¦æ˜¯æœ‰æ•ˆå­—ç¬¦ï¼Œæˆ‘ä»¬å°†å…¶åŠ å…¥ $t$ ä¸­ï¼›

éåŽ†å®Œå½“å‰è¡ŒåŽï¼Œå¦‚æžœ $blockComment$ ä¸º `false`ï¼Œå¹¶ä¸” $t$ ä¸ä¸ºç©ºï¼Œè¯´æ˜Žå½“å‰è¡Œæ˜¯æœ‰æ•ˆè¡Œï¼Œæˆ‘ä»¬å°†å…¶åŠ å…¥ç­”æ¡ˆæ•°ç»„ä¸­ï¼Œå¹¶ä¸”æ¸…ç©º $t$ã€‚ç»§ç»­éåŽ†ä¸‹ä¸€è¡Œã€‚

* [sol1-Python3]

```python
class Solution:
    def removeComments(self, source: List[str]) -> List[str]:
        ans = []
        t = []
        block_comment = False
        for s in source:
            i, m = 0, len(s)
            while i < m:
                if block_comment:
                    if i + 1 < m and s[i : i + 2] == "*/":
                        block_comment = False
                        i += 1
                else:
                    if i + 1 < m and s[i : i + 2] == "/*":
                        block_comment = True
                        i += 1
                    elif i + 1 < m and s[i : i + 2] == "//":
                        break
                    else:
                        t.append(s[i])
                i += 1
            if not block_comment and t:
                ans.append("".join(t))
                t.clear()
        return ans
```

* [sol1-Java]

```java
class Solution {
    public List<String> removeComments(String[] source) {
        List<String> ans = new ArrayList<>();
        StringBuilder sb = new StringBuilder();
        boolean blockComment = false;
        for (String s : source) {
            int m = s.length();
            for (int i = 0; i < m; ++i) {
                if (blockComment) {
                    if (i + 1 < m && s.charAt(i) == '*' && s.charAt(i + 1) == '/') {
                        blockComment = false;
                        ++i;
                    }
                } else {
                    if (i + 1 < m && s.charAt(i) == '/' && s.charAt(i + 1) == '*') {
                        blockComment = true;
                        ++i;
                    } else if (i + 1 < m && s.charAt(i) == '/' && s.charAt(i + 1) == '/') {
                        break;
                    } else {
                        sb.append(s.charAt(i));
                    }
                }
            }
            if (!blockComment && sb.length() > 0) {
                ans.add(sb.toString());
                sb.setLength(0);
            }
        }
        return ans;
    }
}
```

* [sol1-C++]

```cpp
class Solution {
public:
    vector<string> removeComments(vector<string>& source) {
        vector<string> ans;
        string t;
        bool blockComment = false;
        for (auto& s : source) {
            int m = s.size();
            for (int i = 0; i < m; ++i) {
                if (blockComment) {
                    if (i + 1 < m && s[i] == '*' && s[i + 1] == '/') {
                        blockComment = false;
                        ++i;
                    }
                } else {
                    if (i + 1 < m && s[i] == '/' && s[i + 1] == '*') {
                        blockComment = true;
                        ++i;
                    } else if (i + 1 < m && s[i] == '/' && s[i + 1] == '/') {
                        break;
                    } else {
                        t.push_back(s[i]);
                    }
                }
            }
            if (!blockComment && !t.empty()) {
                ans.emplace_back(t);
                t.clear();
            }
        }
        return ans;
    }
};
```

* [sol1-Go]

```go
func removeComments(source []string) (ans []string) {
	t := []byte{}
	blockComment := false
	for _, s := range source {
		m := len(s)
		for i := 0; i < m; i++ {
			if blockComment {
				if i+1 < m && s[i] == '*' && s[i+1] == '/' {
					blockComment = false
					i++
				}
			} else {
				if i+1 < m && s[i] == '/' && s[i+1] == '*' {
					blockComment = true
					i++
				} else if i+1 < m && s[i] == '/' && s[i+1] == '/' {
					break
				} else {
					t = append(t, s[i])
				}
			}
		}
		if !blockComment && len(t) > 0 {
			ans = append(ans, string(t))
			t = []byte{}
		}
	}
	return
}
```

* [sol1-Rust]

```rust
impl Solution {
    pub fn remove_comments(source: Vec<String>) -> Vec<String> {
        let mut ans: Vec<String> = Vec::new();
        let mut t: Vec<String> = Vec::new();
        let mut blockComment = false;

        for s in &source {
            let m = s.len();
            let mut i = 0;
            while i < m {
                if blockComment {
                    if i + 1 < m && &s[i..i + 2] == "*/" {
                        blockComment = false;
                        i += 2;
                    } else {
                        i += 1;
                    }
                } else {
                    if i + 1 < m && &s[i..i + 2] == "/*" {
                        blockComment = true;
                        i += 2;
                    } else if i + 1 < m && &s[i..i + 2] == "//" {
                        break;
                    } else {
                        t.push(s.chars().nth(i).unwrap().to_string());
                        i += 1;
                    }
                }
            }
            if !blockComment && !t.is_empty() {
                ans.push(t.join(""));
                t.clear();
            }
        }
        ans
    }
}
```

* [sol1-TypeScript]

```ts
function removeComments(source: string[]): string[] {
    const ans: string[] = [];
    const t: string[] = [];
    let blockComment = false;
    for (const s of source) {
        const m = s.length;
        for (let i = 0; i < m; ++i) {
            if (blockComment) {
                if (i + 1 < m && s.slice(i, i + 2) === '*/') {
                    blockComment = false;
                    ++i;
                }
            } else {
                if (i + 1 < m && s.slice(i, i + 2) === '/*') {
                    blockComment = true;
                    ++i;
                } else if (i + 1 < m && s.slice(i, i + 2) === '//') {
                    break;
                } else {
                    t.push(s[i]);
                }
            }
        }
        if (!blockComment && t.length) {
            ans.push(t.join(''));
            t.length = 0;
        }
    }
    return ans;
}
```

æ—¶é—´å¤æ‚åº¦ $O(L)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(L)$ï¼Œå…¶ä¸­ $L$ æ˜¯æºä»£ç çš„æ€»é•¿åº¦ã€‚

---

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿Žè¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿Žè¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµžæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆðŸ˜„~
