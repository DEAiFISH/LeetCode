![动态规划-背包问题](https://pic.leetcode-cn.com/1625278423-Ealmfh-file_1625278423079)

**不少同学对背包问题还处于朦胧状态，我特意录了一期视频[带你学透0-1背包问题！](https://www.bilibili.com/video/BV1cg411g7Y6)**，这里详细介绍了0-1背包的中dp数组的定义，初始化，递推公式，以及遍历顺序。相信结合本篇题解，会对你学习背包有所帮助。

## 思路

这是一道典型的背包问题，一看到钱币数量不限，就知道这是一个完全背包。

对完全背包还不了解的同学，可以看这篇：[动态规划：关于完全背包，你该了解这些！](https://programmercarl.com/背包问题理论基础完全背包.html)

但本题和纯完全背包不一样，**纯完全背包是能否凑成总金额，而本题是要求凑成总金额的个数！**

注意题目描述中是凑成总金额的硬币组合数，为什么强调是组合数呢？

例如示例一：

5 = 2 + 2 + 1

5 = 2 + 1 + 2

这是一种组合，都是 2 2 1。

如果问的是排列数，那么上面就是两种排列了。

**组合不强调元素之间的顺序，排列强调元素之间的顺序**。 其实这一点我们在讲解回溯算法专题的时候就讲过了哈。

那我为什么要介绍这些呢，因为这和下文讲解遍历顺序息息相关!

回归本题，动规五步曲来分析如下：

1. 确定dp数组以及下标的含义

dp[j]：凑成总金额j的货币组合数为dp[j]

2. 确定递推公式

dp[j] （考虑coins[i]的组合总和） 就是所有的dp[j - coins[i]]（不考虑coins[i]）相加。

所以递推公式：dp[j] += dp[j - coins[i]];

**这个递推公式大家应该不陌生了，我在讲解01背包题目的时候在这篇[动态规划：目标和！](https://programmercarl.com/0494.目标和.html)中就讲解了，求装满背包有几种方法，一般公式都是：dp[j] += dp[j - nums[i]];**

3. dp数组如何初始化

首先dp[0]一定要为1，dp[0] = 1是 递归公式的基础。

从dp[i]的含义上来讲就是，凑成总金额0的货币组合数为1。

下标非0的dp[j]初始化为0，这样累计加dp[j - coins[i]]的时候才不会影响真正的dp[j]

4. 确定遍历顺序

本题中我们是外层for循环遍历物品（钱币），内层for遍历背包（金钱总额），还是外层for遍历背包（金钱总额），内层for循环遍历物品（钱币）呢？

我在[动态规划：关于完全背包，你该了解这些！](https://programmercarl.com/背包问题理论基础完全背包.html)中讲解了完全背包的两个for循环的先后顺序都是可以的。

**但本题就不行了！**

因为纯完全背包求得是能否凑成总和，和凑成总和的元素有没有顺序没关系，即：有顺序也行，没有顺序也行！

而本题要求凑成总和的组合数，元素之间要求没有顺序。

所以纯完全背包是能凑成总和就行，不用管怎么凑的。

本题是求凑出来的方案个数，且每个方案个数是为组合数。

那么本题，两个for循环的先后顺序可就有说法了。

我们先来看 外层for循环遍历物品（钱币），内层for遍历背包（金钱总额）的情况。

代码如下：

* CPP

```CPP
for (int i = 0; i < coins.size(); i++) { // 遍历物品
    for (int j = coins[i]; j <= amount; j++) { // 遍历背包容量
        dp[j] += dp[j - coins[i]];
    }
}
```

假设：coins[0] = 1，coins[1] = 5。

那么就是先把1加入计算，然后再把5加入计算，得到的方法数量只有{1, 5}这种情况。而不会出现{5, 1}的情况。

**所以这种遍历顺序中dp[j]里计算的是组合数！**

如果把两个for交换顺序，代码如下：

* 

```
for (int j = 0; j <= amount; j++) { // 遍历背包容量
    for (int i = 0; i < coins.size(); i++) { // 遍历物品
        if (j - coins[i] >= 0) dp[j] += dp[j - coins[i]];
    }
}
```

背包容量的每一个值，都是经过 1 和 5 的计算，包含了{1, 5} 和 {5, 1}两种情况。

**此时dp[j]里算出来的就是排列数！**

可能这里很多同学还不是很理解，**建议动手把这两种方案的dp数组数值变化打印出来，对比看一看！（实践出真知）**

5. 举例推导dp数组

输入: amount = 5, coins = [1, 2, 5] ，dp状态图如下：

![518.零钱兑换II](https://pic.leetcode-cn.com/1630637442-UqULMD-file_1630637442195)

最后红色框dp[amount]为最终结果。

以上分析完毕，C++代码如下：

* CPP

```CPP
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<int> dp(amount + 1, 0);
        dp[0] = 1;
        for (int i = 0; i < coins.size(); i++) { // 遍历物品
            for (int j = coins[i]; j <= amount; j++) { // 遍历背包
                dp[j] += dp[j - coins[i]];
            }
        }
        return dp[amount];
    }
};
```

是不是发现代码如此精简，哈哈

## 总结

本题的递推公式，其实我们在[动态规划：目标和！](https://programmercarl.com/0494.目标和.html)中就已经讲过了，**而难点在于遍历顺序！**

在求装满背包有几种方案的时候，认清遍历顺序是非常关键的。

**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。

**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。

可能说到排列数录友们已经有点懵了，后面Carl还会安排求排列数的题目，到时候在对比一下，大家就会发现神奇所在！

## 其他语言版本

Java：

* Java

```Java
class Solution {
    public int change(int amount, int[] coins) {
        //递推表达式
        int[] dp = new int[amount + 1];
        //初始化dp数组，表示金额为0时只有一种情况，也就是什么都不装
        dp[0] = 1;
        for (int i = 0; i < coins.length; i++) {
            for (int j = coins[i]; j <= amount; j++) {
                dp[j] += dp[j - coins[i]];
            }
        }
        return dp[amount];
    }
}
```

Python：

* python3

```python3
class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        dp = [0]*(amount + 1)
        dp[0] = 1
        # 遍历物品
        for i in range(len(coins)):
            # 遍历背包
            for j in range(coins[i], amount + 1):
                dp[j] += dp[j - coins[i]]
        return dp[amount]
```

Go：

* go

```go
func change(amount int, coins []int) int {
	// 定义dp数组
	dp := make([]int, amount+1)
	// 初始化,0大小的背包, 当然是不装任何东西了, 就是1种方法
	dp[0]  = 1
	// 遍历顺序
	// 遍历物品
	for i := 0 ;i < len(coins);i++ {
		// 遍历背包
		for j:= coins[i] ; j <= amount ;j++ {
			// 推导公式
			dp[j] += dp[j-coins[i]]
		}
	}
	return dp[amount]
}
```

Javascript：

* javascript

```javascript
const change = (amount, coins) => {
    let dp = Array(amount + 1).fill(0);
    dp[0] = 1;

    for(let i =0; i < coins.length; i++) {
        for(let j = coins[i]; j <= amount; j++) {
            dp[j] += dp[j - coins[i]];
        }
    }

    return dp[amount];
}
```

# 背包问题力扣完整攻略

只要按如下顺序刷题，相信会帮你在学习背包问题的路上少走很多弯路！

* 0-1背包
  * [01背包问题理论基础二维dp数组](https://programmercarl.com/背包理论基础01背包-1.html)
  * [01背包问题理论基础一维dp数组（滚动数组）](https://programmercarl.com/背包理论基础01背包-2.html)
  * [416.分割等和子集](https://programmercarl.com/0416.分割等和子集.html)
  * [1049.最后一块石头的重量 II](https://programmercarl.com/1049.最后一块石头的重量II.html)
  * [494.目标和](https://programmercarl.com/0494.目标和.html)
  * [474.一和零](https://programmercarl.com/0474.一和零.html)
* 完全背包
  * [动态规划：关于完全背包，你该了解这些！](https://programmercarl.com/背包问题理论基础完全背包.html)
  * [518. 零钱兑换 II](https://programmercarl.com/0518.零钱兑换II.html)
  * [0377.组合总和Ⅳ.](https://programmercarl.com/0377.组合总和Ⅳ.html)
  * [70.爬楼梯进阶版](https://programmercarl.com/0070.爬楼梯完全背包版本.html)
  * [322. 零钱兑换](https://programmercarl.com/0322.零钱兑换.html)
  * [279.完全平方数](https://programmercarl.com/0279.完全平方数.html)
  * [139.单词拆分](https://programmercarl.com/0139.单词拆分.html)
* 多重背包
  * [动态规划：关于多重背包，你该了解这些！](https://programmercarl.com/背包问题理论基础多重背包.html)
* [背包问题总结篇](https://programmercarl.com/背包总结篇.html)

-----------

**大家好，我是程序员Carl，点击[我的头像](https://programmercarl.com/)**，查看力扣详细刷题攻略，你会发现相见恨晚！

**如果感觉题解对你有帮助，不要吝啬给一个👍吧！**
