[113. 路径总和 II](https://leetcode.cn/problems/path-sum-ii/description/)

注意：slice 需要 copy，防止各递归函数共同修改同一个slice造成不一致，[go slice 的 copy 有很多方式](https://gosamples.dev/copy-slice/)

# BFS

同 LeetCode 112，只是列出了完整的路径。

* []

```go
// go
package main

type TreeNode struct {
	Val   int
	Left  *TreeNode
	Right *TreeNode
}

func N(v int, l, r *TreeNode) *TreeNode {
	return &TreeNode{v, l, r}
}

func main() {
	l := N(4, N(11, N(7, nil, nil), N(2, nil, nil)), nil)
	r := N(8, N(13, nil, nil), N(4, N(5, nil, nil), N(1, nil, nil)))
	n := N(5, l, r)
	println(pathSum(n, 22))
}

func pathSum(root *TreeNode, targetSum int) (ans [][]int) {
	if root == nil {
		return
	}
	q := []*VNode{{root, root.Val, []int{root.Val}}}
	for len(q) > 0 {
		n := q[0]
		q = q[1:]
		if n.Left == nil && n.Right == nil && n.curSum == targetSum {
			ans = append(ans, n.path)
		}
		if n.Left != nil {
			q = append(q, n.AddPath(n.Left))
		}
		if n.Right != nil {
			q = append(q, n.AddPath(n.Right))
		}
	}
	return
}

type VNode struct {
	*TreeNode
	curSum int
	path   []int
}

func (v VNode) AddPath(x *TreeNode) *VNode {
	p := make([]int, len(v.path)) // 注意，这里必须要copy，而不能用 append(v.path, x.Val)，否则v.path数组会被修改引发不可预料的问题
	copy(p, v.path)
	return &VNode{
		TreeNode: x,
		curSum:   v.curSum + x.Val,
		path:     append(p, x.Val),
	}
}
```

# DFS

* []

```go
package main

func pathSum(root *TreeNode, target int) (ans [][]int) {
    var f func(n *TreeNode, tar int, path []int) (arr []int)
    f = func(n *TreeNode, tar int, path []int) (arr []int) {
        if n == nil {return}
        arr = append(arr, path...); arr = append(arr, n.Val) // copy, 防止各递归函数共同修改同一个slice造成不一致
        tar -= n.Val
        if tar == 0 && n.Left == nil && n.Right == nil {ans = append(ans, arr); return} // 找到了
        // if tar < 0 {return} // 因为题意可能n.Val是负数（如 root=[-2,null,-3], target=-5），所以不可加此终止条件
        f(n.Left, tar, arr)
        f(n.Right, tar, arr)
        return
    }
    f(root, target, []int{})
    return
}

type TreeNode struct {
	Val   int
	Left  *TreeNode
	Right *TreeNode
}

func N(v int, l, r *TreeNode) *TreeNode {
	return &TreeNode{v, l, r}
}

func main() {
	//l := N(4, N(11, N(7, nil, nil), N(2, nil, nil)), nil)
	//r := N(8, N(13, nil, nil), N(4, N(5, nil, nil), N(1, nil, nil)))
	//n := N(5, l, r)
	//println(pathSum(n, 22))
	n := N(-2, nil, N(-3, nil, nil))
	println(pathSum(n, -5))
}
```

