# 方法一：模拟

由于`1 <= n <= 200`，数据量比较小
所以可以直接写个暴力模拟
题目要你干什么你就干什么

* 

```
int equalPairs(int** grid, int gridSize, int* gridColSize) {
    int n = gridSize, ans = 0; //矩阵长度   答案
    for (int i = 0; i < n; i++) { //遍历行
        for (int j = 0; j < n; j++) { //遍历列
            bool falg = true; //判断是否相等
            for (int k = 0; k < n; k++) { //按题目要求，对行和列进行比对
                if (grid[i][k] != grid[k][j]) { //如果有一个不等
                    falg = false; //更新为不相等
                    break; //跳出循环
                }
            }
            ans += falg; //记录答案
        }
    }
    return ans;
}
```

**复杂度分析**
- 时间复杂度：O(n³)，三重for循环嵌套
- 空间复杂度：O(1)

![image.png](https://pic.leetcode.cn/1686014905-TeGVZs-image.png)

# 方法二：空间匹配

可以对上述模拟进行优化
将一列数组存入到临时数组`tmp[n]`中
再用空间匹配函数`memcmp()`去比较`tmp`与`grid[i]`是否相同

* 

```
int equalPairs(int** grid, int gridSize, int* gridColSize) {
    int n = gridSize, ans = 0, tmp[n]; //矩阵长度   答案   临时数组
    for (int j = 0; j < n; j++) { //遍历列
        for (int i = 0; i < n; i++) { //遍历行
            tmp[i] = grid[i][j]; //将该列存入到临时数组中
        }
        for (int i = 0; i < n; i++) { //遍历行
            ans += memcmp(tmp, grid[i], sizeof(tmp)) == 0; //判断是否相等，相等则记录答案
        }
    }
    return ans;
}
```

**复杂度分析**
- 时间复杂度：O(n³)，需要进行双重循环，每次循环都要使用O(n)的时间进行空间匹配
- 空间复杂度：O(n)，临时数组的内存开销

![image.png](https://pic.leetcode.cn/1686015391-tJbAGW-image.png)

# 方法三：字符串哈希

利用哈希表，可以做到O(n^2)的时间复杂度

将每一行数组转化为字符串，数与数之间用空格符`' '`隔开
将该字符串放入到临时字符串`tmp[7n+1]`中

随后通过该字符串去求得它的键值`key`
将键值映射到哈希数组中的下标`hash[key % HASH_SIZE]`
**其中，`hash[i]`表示：键值为`key`的字符串出现的次数**
**我们假定，每一个键值`key`都单独地表示唯一一个字符串`s`**

为了避免哈希冲突，需要将哈希表的大小，开的尽可能的大，而且最好是质数
例如：`HASH_SIZE = 1000007`

在计算键值`key`的时候，为了让每一个键值`key`都单独地映射到唯一一个字符串`s`
需要对键值`key`进行初始化为质数`key = 5381`
并且在遍历字符串`s`的时候，对`key`进行更新
更新的时候采用的哈希函数，应当尽可能地没有规律，并且要加上`s[i]`
以`key = (long long)(key << 5) % mod + key + s[i]`为例
以此来达到：让每一个键值`key`都单独地表示唯一一个字符串`s`的目的

* 

```
#define HASH_SIZE 1000007 //哈希表大小

unsigned int GetKey(const char* s) { //计算字符串的键值
    unsigned int key = 5381, mod = 1e9; //键值   模数
    for (int i = 0; s[i]; i++) { //遍历一遍字符串
        key = (long long)(key << 5) % mod + key + s[i]; //更新键值
    }
    return key; //返回表示该字符串的键值
}

int equalPairs(int** grid, int gridSize, int* gridColSize) {
    int n = gridSize, ans = 0; //矩阵长度   答案
    short int hash[HASH_SIZE]; //哈希数组
    memset(hash, 0, sizeof(hash)); //初置为0
    char tmp[7 * n + 1]; //临时字符串
    for (int i = 0; i < n; i++) { //遍历行
        int pos = 0; //临时字符串的下标
        for (int j = 0; j < n; j++) { //遍历列
            pos += sprintf(tmp + pos, "%d ", grid[i][j]); //将该行转为字符串，并存入到临时字符串中
        }
        tmp[pos] = '\0'; //字符串结尾添'\0'
        unsigned int key = GetKey(tmp); //获得该字符串的键值
        hash[key % HASH_SIZE]++; //映射到哈希集合中
    }
    for (int j = 0; j < n; j++) { //遍历列
        int pos = 0; //临时字符串的下标
        for (int i = 0; i < n; i++) { //遍历行
            pos += sprintf(tmp + pos, "%d ", grid[i][j]); //将该列转为字符串，并存入到临时字符串中
        }
        tmp[pos] = '\0'; //字符串结尾添'\0'
        unsigned int key = GetKey(tmp); //获得该字符串的键值
        ans += hash[key % HASH_SIZE]; //将与该列字符串相等的行字符串的个数，加入答案中
    }
    return ans;
}
```

**复杂度分析**
记`C = HASH_SIZE`
- 时间复杂度：O(n²+C)，初始化哈希数组需要O(C)的时间
  将每行每列数组转为字符串需要O(n²)的时间，计算每行或每列字符串的键值也需要O(n²)的时间
- 空间复杂度：O(n+C)，临时字符串需要O(n)的空间，哈希数组需要O(C)的空间

![image.png](https://pic.leetcode.cn/1686017681-xVPtJH-image.png)

P.S：
1. 由于数据量很小，所以与开哈希表相比，还不如直接暴力模拟
   因为`HASH_SIZE`比`n`大得多，所以没必要
2. 为什么空间匹配效率那么好，我觉得时间复杂度应该是和暴力一样的啊？

