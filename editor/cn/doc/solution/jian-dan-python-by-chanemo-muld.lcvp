**核心观念：编程实际上是用计算机实现人工能干的事情。**
因此解题可以遵循 “**人工推导——从个体到群体——从特殊到普遍**” 的思路，即从个例推出通解。
以本题示例一为例：数组 `[2, 7, 11, 15]`，目标为 `9`，显然如果是人来做这道题，最简单的
想法应当是遍历整个数组，逐个寻找是否存在答案：

    Round 1：先取元素 2，根据 9-2=7，下一步寻找7是否在剩下的元素中，若在则返回下标，此时答案为 `[0, 1]`
    Round 2：先取元素 7，根据 9-7=2，下一步寻找2是否在剩下的元素中，若在则返回下标，此时答案为 `[1, 0]`
    ······
    Round 4：先取元素 11，9-11=-2，-2 不在数组 `nums` 中，故排除此种情况

由于题目保证仅存在一个答案，故遍历过程中只要存在一个解，即可返回结果；同时，可以注意到，上例的遍历过程存在一定的重复，如遍历了元素 2 之后，结果为 2+7=9，但若再遍历下一个元素 7 时，结果为 7+2=9，二者返回的是相同的数字组合，只不过顺序不同。因此，遍历当前元素时无需从该元素前面的元素中找答案。
到这里，我们可以将上述的思路以及从示例中推导出的解题步骤转化为代码了：

* []

```Python
代码块
class Solution(object):
    def twoSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        # 遍历列表
        for i in range(len(nums)):
            # 计算需要找到的下一个目标数字
            res = target-nums[i]
                # 遍历剩下的元素，查找是否存在该数字
            if res in nums[i+1:]:
                # 若存在，返回答案。这里由于是两数之和，可采用.index()方法
                # 获得目标元素在nums[i+1:]这个子数组中的索引后，还需加上i+1才是该元素在nums中的索引
                return [i, nums[i+1:].index(res)+i+1]
```

这样我们就完成了人工推导到编程实现的过程，之后便可考虑进一步优化代码的时间及空间花销了。网上有很多大神们的优化思路，此处不再赘述。
