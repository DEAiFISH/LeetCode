### ğŸ“º è§†é¢‘é¢˜è§£

![215. æ•°ç»„ä¸­çš„ç¬¬Kä¸ªæœ€å¤§å…ƒç´ .mp4](https://leetcode.cn/problems/kth-largest-element-in-an-array/solution/shu-zu-zhong-de-di-kge-zui-da-yuan-su-by-leetcode-/9c5f6d66-f7ed-4d98-a8f4-5629eb8ed376)

### ğŸ“– æ–‡å­—é¢˜è§£

#### å‰è¨€

+ çº¦å®šï¼šå‡è®¾è¿™é‡Œæ•°ç»„çš„é•¿åº¦ä¸º $n$ã€‚

+ é¢˜ç›®åˆ†æï¼šæœ¬é¢˜å¸Œæœ›æˆ‘ä»¬è¿”å›æ•°ç»„æ’åºä¹‹åçš„å€’æ•°ç¬¬ $k$ ä¸ªä½ç½®ã€‚

#### æ–¹æ³•ä¸€ï¼šåŸºäºå¿«é€Ÿæ’åºçš„é€‰æ‹©æ–¹æ³•

**æ€è·¯å’Œç®—æ³•**

æˆ‘ä»¬å¯ä»¥ç”¨å¿«é€Ÿæ’åºæ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå…ˆå¯¹åŸæ•°ç»„æ’åºï¼Œå†è¿”å›å€’æ•°ç¬¬ $k$ ä¸ªä½ç½®ï¼Œè¿™æ ·å¹³å‡æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n \log n)$ï¼Œä½†å…¶å®æˆ‘ä»¬å¯ä»¥åšçš„æ›´å¿«ã€‚

é¦–å…ˆæˆ‘ä»¬æ¥å›é¡¾ä¸€ä¸‹å¿«é€Ÿæ’åºï¼Œè¿™æ˜¯ä¸€ä¸ªå…¸å‹çš„åˆ†æ²»ç®—æ³•ã€‚æˆ‘ä»¬å¯¹æ•°ç»„ $a[l \cdots r]$ åšå¿«é€Ÿæ’åºçš„è¿‡ç¨‹æ˜¯ï¼ˆå‚è€ƒã€Šç®—æ³•å¯¼è®ºã€‹ï¼‰ï¼š

+ **åˆ†è§£ï¼š** å°†æ•°ç»„ $a[l \cdots r]$ ã€Œåˆ’åˆ†ã€æˆä¸¤ä¸ªå­æ•°ç»„ $a[l \cdots q - 1]$ã€$a[q + 1 \cdots r]$ï¼Œä½¿å¾— $a[l \cdots q - 1]$ ä¸­çš„æ¯ä¸ªå…ƒç´ å°äºç­‰äº $a[q]$ï¼Œä¸” $a[q]$ å°äºç­‰äº $a[q + 1 \cdots r]$ ä¸­çš„æ¯ä¸ªå…ƒç´ ã€‚å…¶ä¸­ï¼Œè®¡ç®—ä¸‹æ ‡ $q$ ä¹Ÿæ˜¯ã€Œåˆ’åˆ†ã€è¿‡ç¨‹çš„ä¸€éƒ¨åˆ†ã€‚
+ **è§£å†³ï¼š** é€šè¿‡é€’å½’è°ƒç”¨å¿«é€Ÿæ’åºï¼Œå¯¹å­æ•°ç»„ $a[l \cdots q - 1]$ å’Œ $a[q + 1 \cdots r]$ è¿›è¡Œæ’åºã€‚
+ **åˆå¹¶ï¼š** å› ä¸ºå­æ•°ç»„éƒ½æ˜¯åŸå€æ’åºçš„ï¼Œæ‰€ä»¥ä¸éœ€è¦è¿›è¡Œåˆå¹¶æ“ä½œï¼Œ$a[l \cdots r]$ å·²ç»æœ‰åºã€‚
+ ä¸Šæ–‡ä¸­æåˆ°çš„ **ã€Œåˆ’åˆ†ã€** è¿‡ç¨‹æ˜¯ï¼šä»å­æ•°ç»„ $a[l \cdots r]$ ä¸­é€‰æ‹©ä»»æ„ä¸€ä¸ªå…ƒç´  $x$ ä½œä¸ºä¸»å…ƒï¼Œ**è°ƒæ•´å­æ•°ç»„çš„å…ƒç´ ä½¿å¾—å·¦è¾¹çš„å…ƒç´ éƒ½å°äºç­‰äºå®ƒï¼Œå³è¾¹çš„å…ƒç´ éƒ½å¤§äºç­‰äºå®ƒï¼Œ** $x$ çš„æœ€ç»ˆä½ç½®å°±æ˜¯ $q$ã€‚

ç”±æ­¤å¯ä»¥å‘ç°æ¯æ¬¡ç»è¿‡ã€Œåˆ’åˆ†ã€æ“ä½œåï¼Œæˆ‘ä»¬ä¸€å®šå¯ä»¥ç¡®å®šä¸€ä¸ªå…ƒç´ çš„æœ€ç»ˆä½ç½®ï¼Œå³ $x$ çš„æœ€ç»ˆä½ç½®ä¸º $q$ï¼Œå¹¶ä¸”ä¿è¯ $a[l \cdots q - 1]$ ä¸­çš„æ¯ä¸ªå…ƒç´ å°äºç­‰äº $a[q]$ï¼Œä¸” $a[q]$ å°äºç­‰äº $a[q + 1 \cdots r]$ ä¸­çš„æ¯ä¸ªå…ƒç´ ã€‚**æ‰€ä»¥åªè¦æŸæ¬¡åˆ’åˆ†çš„ $q$ ä¸ºå€’æ•°ç¬¬ $k$ ä¸ªä¸‹æ ‡çš„æ—¶å€™ï¼Œæˆ‘ä»¬å°±å·²ç»æ‰¾åˆ°äº†ç­”æ¡ˆã€‚** æˆ‘ä»¬åªå…³å¿ƒè¿™ä¸€ç‚¹ï¼Œè‡³äº $a[l \cdots q - 1]$ å’Œ $a[q+1 \cdots r]$ æ˜¯å¦æ˜¯æœ‰åºçš„ï¼Œæˆ‘ä»¬ä¸å…³å¿ƒã€‚

å› æ­¤æˆ‘ä»¬å¯ä»¥æ”¹è¿›å¿«é€Ÿæ’åºç®—æ³•æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼šåœ¨åˆ†è§£çš„è¿‡ç¨‹å½“ä¸­ï¼Œæˆ‘ä»¬ä¼šå¯¹å­æ•°ç»„è¿›è¡Œåˆ’åˆ†ï¼Œå¦‚æœåˆ’åˆ†å¾—åˆ°çš„ $q$ æ­£å¥½å°±æ˜¯æˆ‘ä»¬éœ€è¦çš„ä¸‹æ ‡ï¼Œå°±ç›´æ¥è¿”å› $a[q]$ï¼›å¦åˆ™ï¼Œå¦‚æœ $q$ æ¯”ç›®æ ‡ä¸‹æ ‡å°ï¼Œå°±é€’å½’å³å­åŒºé—´ï¼Œå¦åˆ™é€’å½’å·¦å­åŒºé—´ã€‚è¿™æ ·å°±å¯ä»¥æŠŠåŸæ¥é€’å½’ä¸¤ä¸ªåŒºé—´å˜æˆåªé€’å½’ä¸€ä¸ªåŒºé—´ï¼Œæé«˜äº†æ—¶é—´æ•ˆç‡ã€‚è¿™å°±æ˜¯ã€Œå¿«é€Ÿé€‰æ‹©ã€ç®—æ³•ã€‚

æˆ‘ä»¬çŸ¥é“å¿«é€Ÿæ’åºçš„æ€§èƒ½å’Œã€Œåˆ’åˆ†ã€å‡ºçš„å­æ•°ç»„çš„é•¿åº¦å¯†åˆ‡ç›¸å…³ã€‚ç›´è§‚åœ°ç†è§£å¦‚æœæ¯æ¬¡è§„æ¨¡ä¸º $n$ çš„é—®é¢˜æˆ‘ä»¬éƒ½åˆ’åˆ†æˆ $1$ å’Œ $n - 1$ï¼Œæ¯æ¬¡é€’å½’çš„æ—¶å€™åˆå‘ $n - 1$ çš„é›†åˆä¸­é€’å½’ï¼Œè¿™ç§æƒ…å†µæ˜¯æœ€åçš„ï¼Œæ—¶é—´ä»£ä»·æ˜¯ $O(n ^ 2)$ã€‚æˆ‘ä»¬å¯ä»¥å¼•å…¥éšæœºåŒ–æ¥åŠ é€Ÿè¿™ä¸ªè¿‡ç¨‹ï¼Œå®ƒçš„æ—¶é—´ä»£ä»·çš„æœŸæœ›æ˜¯ $O(n)$ï¼Œè¯æ˜è¿‡ç¨‹å¯ä»¥å‚è€ƒã€Œã€Šç®—æ³•å¯¼è®ºã€‹9.2ï¼šæœŸæœ›ä¸ºçº¿æ€§çš„é€‰æ‹©ç®—æ³•ã€ã€‚

**ä»£ç **

* [sol1-C++]

```cpp
class Solution {
public:
    int quickSelect(vector<int>& a, int l, int r, int index) {
        int q = randomPartition(a, l, r);
        if (q == index) {
            return a[q];
        } else {
            return q < index ? quickSelect(a, q + 1, r, index) : quickSelect(a, l, q - 1, index);
        }
    }

    inline int randomPartition(vector<int>& a, int l, int r) {
        int i = rand() % (r - l + 1) + l;
        swap(a[i], a[r]);
        return partition(a, l, r);
    }

    inline int partition(vector<int>& a, int l, int r) {
        int x = a[r], i = l - 1;
        for (int j = l; j < r; ++j) {
            if (a[j] <= x) {
                swap(a[++i], a[j]);
            }
        }
        swap(a[i + 1], a[r]);
        return i + 1;
    }

    int findKthLargest(vector<int>& nums, int k) {
        srand(time(0));
        return quickSelect(nums, 0, nums.size() - 1, nums.size() - k);
    }
};
```

* [sol1-Java]

```Java
class Solution {
    Random random = new Random();

    public int findKthLargest(int[] nums, int k) {
        return quickSelect(nums, 0, nums.length - 1, nums.length - k);
    }

    public int quickSelect(int[] a, int l, int r, int index) {
        int q = randomPartition(a, l, r);
        if (q == index) {
            return a[q];
        } else {
            return q < index ? quickSelect(a, q + 1, r, index) : quickSelect(a, l, q - 1, index);
        }
    }

    public int randomPartition(int[] a, int l, int r) {
        int i = random.nextInt(r - l + 1) + l;
        swap(a, i, r);
        return partition(a, l, r);
    }

    public int partition(int[] a, int l, int r) {
        int x = a[r], i = l - 1;
        for (int j = l; j < r; ++j) {
            if (a[j] <= x) {
                swap(a, ++i, j);
            }
        }
        swap(a, i + 1, r);
        return i + 1;
    }

    public void swap(int[] a, int i, int j) {
        int temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}
```

* [sol1-C]

```C
inline int partition(int* a, int l, int r) {
    int x = a[r], i = l - 1;
    for (int j = l; j < r; ++j) {
        if (a[j] <= x) {
            int t = a[++i];
            a[i] = a[j], a[j] = t;
        }
    }
    int t = a[i + 1];
    a[i + 1] = a[r], a[r] = t;
    return i + 1;
}

inline int randomPartition(int* a, int l, int r) {
    int i = rand() % (r - l + 1) + l;
    int t = a[i];
    a[i] = a[r], a[r] = t;
    return partition(a, l, r);
}

int quickSelect(int* a, int l, int r, int index) {
    int q = randomPartition(a, l, r);
    if (q == index) {
        return a[q];
    } else {
        return q < index ? quickSelect(a, q + 1, r, index)
                         : quickSelect(a, l, q - 1, index);
    }
}

int findKthLargest(int* nums, int numsSize, int k) {
    srand(time(0));
    return quickSelect(nums, 0, numsSize - 1, numsSize - k);
}
```

* [sol1-Golang]

```golang
func findKthLargest(nums []int, k int) int {
    rand.Seed(time.Now().UnixNano())
    return quickSelect(nums, 0, len(nums)-1, len(nums)-k)
}

func quickSelect(a []int, l, r, index int) int {
    q := randomPartition(a, l, r)
    if q == index {
        return a[q]
    } else if q < index {
        return quickSelect(a, q + 1, r, index)
    }
    return quickSelect(a, l, q - 1, index)
}

func randomPartition(a []int, l, r int) int {
    i := rand.Int() % (r - l + 1) + l
    a[i], a[r] = a[r], a[i]
    return partition(a, l, r)
}

func partition(a []int, l, r int) int {
    x := a[r]
    i := l - 1
    for j := l; j < r; j++ {
        if a[j] <= x {
            i++
            a[i], a[j] = a[j], a[i]
        }
    }
    a[i+1], a[r] = a[r], a[i+1]
    return i + 1
}
```

**å¤æ‚åº¦åˆ†æ**

- æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$ï¼Œå¦‚ä¸Šæ–‡æ‰€è¿°ï¼Œè¯æ˜è¿‡ç¨‹å¯ä»¥å‚è€ƒã€Œã€Šç®—æ³•å¯¼è®ºã€‹9.2ï¼šæœŸæœ›ä¸ºçº¿æ€§çš„é€‰æ‹©ç®—æ³•ã€ã€‚
- ç©ºé—´å¤æ‚åº¦ï¼š$O(\log n)$ï¼Œé€’å½’ä½¿ç”¨æ ˆç©ºé—´çš„ç©ºé—´ä»£ä»·çš„æœŸæœ›ä¸º $O(\log n)$ã€‚

#### æ–¹æ³•äºŒï¼šåŸºäºå †æ’åºçš„é€‰æ‹©æ–¹æ³•

**æ€è·¯å’Œç®—æ³•**

æˆ‘ä»¬ä¹Ÿå¯ä»¥ä½¿ç”¨å †æ’åºæ¥è§£å†³è¿™ä¸ªé—®é¢˜â€”â€”å»ºç«‹ä¸€ä¸ªå¤§æ ¹å †ï¼Œåš $k - 1$ æ¬¡åˆ é™¤æ“ä½œåå †é¡¶å…ƒç´ å°±æ˜¯æˆ‘ä»¬è¦æ‰¾çš„ç­”æ¡ˆã€‚åœ¨å¾ˆå¤šè¯­è¨€ä¸­ï¼Œéƒ½æœ‰ä¼˜å…ˆé˜Ÿåˆ—æˆ–è€…å †çš„çš„å®¹å™¨å¯ä»¥ç›´æ¥ä½¿ç”¨ï¼Œä½†æ˜¯åœ¨é¢è¯•ä¸­ï¼Œé¢è¯•å®˜æ›´å€¾å‘äºè®©æ›´é¢è¯•è€…è‡ªå·±å®ç°ä¸€ä¸ªå †ã€‚æ‰€ä»¥å»ºè®®è¯»è€…æŒæ¡è¿™é‡Œå¤§æ ¹å †çš„å®ç°æ–¹æ³•ï¼Œåœ¨è¿™é“é¢˜ä¸­å°¤å…¶è¦ææ‡‚ã€Œå»ºå †ã€ã€ã€Œè°ƒæ•´ã€å’Œã€Œåˆ é™¤ã€çš„è¿‡ç¨‹ã€‚

**å‹æƒ…æé†’ï¼šã€Œå †æ’ã€åœ¨å¾ˆå¤šå¤§å…¬å¸çš„é¢è¯•ä¸­éƒ½å¾ˆå¸¸è§ï¼Œä¸äº†è§£çš„åŒå­¦å»ºè®®å‚è€ƒã€Šç®—æ³•å¯¼è®ºã€‹æˆ–è€…å¤§å®¶çš„æ•°æ®ç»“æ„æ•™æï¼Œä¸€å®šè¦å­¦ä¼šè¿™ä¸ªçŸ¥è¯†ç‚¹å“¦ï¼^_^**

<![fig1](https://assets.leetcode-cn.com/solution-static/215/1.png),![fig2](https://assets.leetcode-cn.com/solution-static/215/2.png),![fig3](https://assets.leetcode-cn.com/solution-static/215/3.png),![fig4](https://assets.leetcode-cn.com/solution-static/215/4.png),![fig5](https://assets.leetcode-cn.com/solution-static/215/5.png),![fig6](https://assets.leetcode-cn.com/solution-static/215/6.png),![fig7](https://assets.leetcode-cn.com/solution-static/215/7.png),![fig8](https://assets.leetcode-cn.com/solution-static/215/8.png),![fig9](https://assets.leetcode-cn.com/solution-static/215/9.png),![fig10](https://assets.leetcode-cn.com/solution-static/215/10.png),![fig11](https://assets.leetcode-cn.com/solution-static/215/11.png),![fig12](https://assets.leetcode-cn.com/solution-static/215/12.png),![fig13](https://assets.leetcode-cn.com/solution-static/215/13.png),![fig14](https://assets.leetcode-cn.com/solution-static/215/14.png),![fig15](https://assets.leetcode-cn.com/solution-static/215/15.png),![fig16](https://assets.leetcode-cn.com/solution-static/215/16.png),![fig17](https://assets.leetcode-cn.com/solution-static/215/17.png),![fig18](https://assets.leetcode-cn.com/solution-static/215/18.png),![fig19](https://assets.leetcode-cn.com/solution-static/215/19.png),![fig20](https://assets.leetcode-cn.com/solution-static/215/20.png)>

**ä»£ç **

* [sol2-C++]

```cpp
class Solution {
public:
    void maxHeapify(vector<int>& a, int i, int heapSize) {
        int l = i * 2 + 1, r = i * 2 + 2, largest = i;
        if (l < heapSize && a[l] > a[largest]) {
            largest = l;
        } 
        if (r < heapSize && a[r] > a[largest]) {
            largest = r;
        }
        if (largest != i) {
            swap(a[i], a[largest]);
            maxHeapify(a, largest, heapSize);
        }
    }

    void buildMaxHeap(vector<int>& a, int heapSize) {
        for (int i = heapSize / 2; i >= 0; --i) {
            maxHeapify(a, i, heapSize);
        } 
    }

    int findKthLargest(vector<int>& nums, int k) {
        int heapSize = nums.size();
        buildMaxHeap(nums, heapSize);
        for (int i = nums.size() - 1; i >= nums.size() - k + 1; --i) {
            swap(nums[0], nums[i]);
            --heapSize;
            maxHeapify(nums, 0, heapSize);
        }
        return nums[0];
    }
};
```

* [sol2-Java]

```Java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        int heapSize = nums.length;
        buildMaxHeap(nums, heapSize);
        for (int i = nums.length - 1; i >= nums.length - k + 1; --i) {
            swap(nums, 0, i);
            --heapSize;
            maxHeapify(nums, 0, heapSize);
        }
        return nums[0];
    }

    public void buildMaxHeap(int[] a, int heapSize) {
        for (int i = heapSize / 2; i >= 0; --i) {
            maxHeapify(a, i, heapSize);
        } 
    }

    public void maxHeapify(int[] a, int i, int heapSize) {
        int l = i * 2 + 1, r = i * 2 + 2, largest = i;
        if (l < heapSize && a[l] > a[largest]) {
            largest = l;
        } 
        if (r < heapSize && a[r] > a[largest]) {
            largest = r;
        }
        if (largest != i) {
            swap(a, i, largest);
            maxHeapify(a, largest, heapSize);
        }
    }

    public void swap(int[] a, int i, int j) {
        int temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}
```

* [sol2-C]

```C
void maxHeapify(int* a, int i, int heapSize) {
    int l = i * 2 + 1, r = i * 2 + 2, largest = i;
    if (l < heapSize && a[l] > a[largest]) {
        largest = l;
    }
    if (r < heapSize && a[r] > a[largest]) {
        largest = r;
    }
    if (largest != i) {
        int t = a[i];
        a[i] = a[largest], a[largest] = t;
        maxHeapify(a, largest, heapSize);
    }
}

void buildMaxHeap(int* a, int heapSize) {
    for (int i = heapSize / 2; i >= 0; --i) {
        maxHeapify(a, i, heapSize);
    }
}

int findKthLargest(int* nums, int numsSize, int k) {
    int heapSize = numsSize;
    buildMaxHeap(nums, heapSize);
    for (int i = numsSize - 1; i >= numsSize - k + 1; --i) {
        int t = nums[0];
        nums[0] = nums[i], nums[i] = t;
        --heapSize;
        maxHeapify(nums, 0, heapSize);
    }
    return nums[0];
}
```

* [sol2-Golang]

```golang
func findKthLargest(nums []int, k int) int {
    heapSize := len(nums)
    buildMaxHeap(nums, heapSize)
    for i := len(nums) - 1; i >= len(nums) - k + 1; i-- {
        nums[0], nums[i] = nums[i], nums[0]
        heapSize--
        maxHeapify(nums, 0, heapSize)
    }
    return nums[0]
}

func buildMaxHeap(a []int, heapSize int) {
    for i := heapSize/2; i >= 0; i-- {
        maxHeapify(a, i, heapSize)
    }
}

func maxHeapify(a []int, i, heapSize int) {
    l, r, largest := i * 2 + 1, i * 2 + 2, i
    if l < heapSize && a[l] > a[largest] {
        largest = l
    }
    if r < heapSize && a[r] > a[largest] {
        largest = r
    }
    if largest != i {
        a[i], a[largest] = a[largest], a[i]
        maxHeapify(a, largest, heapSize)
    }
}
```

**å¤æ‚åº¦åˆ†æ**

- æ—¶é—´å¤æ‚åº¦ï¼š$O(n \log n)$ï¼Œå»ºå †çš„æ—¶é—´ä»£ä»·æ˜¯ $O(n)$ï¼Œåˆ é™¤çš„æ€»ä»£ä»·æ˜¯ $O(k \log n)$ï¼Œå› ä¸º $k < n$ï¼Œæ•…æ¸è¿›æ—¶é—´å¤æ‚ä¸º $O(n + k \log n) = O(n \log n)$ã€‚
- ç©ºé—´å¤æ‚åº¦ï¼š$O(\log n)$ï¼Œå³é€’å½’ä½¿ç”¨æ ˆç©ºé—´çš„ç©ºé—´ä»£ä»·ã€‚

